'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _class,_temp;var _react=require('react');var _react2=_interopRequireDefault(_react);var _scroll=require('scroll');var _scroll2=_interopRequireDefault(_scroll);var _reactAutobind=require('react-autobind');var _reactAutobind2=_interopRequireDefault(_reactAutobind);var _nestedProperty=require('nested-property');var _nestedProperty2=_interopRequireDefault(_nestedProperty);var _utils=require('./utils');var _Beacon=require('./Beacon');var _Beacon2=_interopRequireDefault(_Beacon);var _Tooltip=require('./Tooltip');var _Tooltip2=_interopRequireDefault(_Tooltip);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var defaultState={action:'',index:0,play:false,redraw:true,shouldPlay:false,showTooltip:false,xPos:-1000,yPos:-1000,skipped:false};var callbackTypes={STEP_BEFORE:'step:before',BEACON_BEFORE:'beacon:before',BEACON_TRIGGER:'beacon:trigger',TOOLTIP_BEFORE:'tooltip:before',STEP_AFTER:'step:after',STANDALONE_BEFORE:'standalone:before',STANDALONE_AFTER:'standalone:after',OVERLAY:'overlay:click',HOLE:'hole:click',FINISHED:'finished'};var listeners={tooltips:{}};var STEP_DEFAULTS={position:'top'};var isTouch=false;if(typeof window!=='undefined'){isTouch='ontouchstart'in window||navigator.msMaxTouchPoints;}var Joyride=(_temp=_class=function(_React$Component){_inherits(Joyride,_React$Component);function Joyride(props){_classCallCheck(this,Joyride);var _this=_possibleConstructorReturn(this,(Joyride.__proto__||Object.getPrototypeOf(Joyride)).call(this,props));(0,_reactAutobind2.default)(_this);_this.state=defaultState;return _this;}_createClass(Joyride,[{key:'componentDidMount',value:function componentDidMount(){var _this2=this;var _props=this.props,autoStart=_props.autoStart,keyboardNavigation=_props.keyboardNavigation,resizeDebounce=_props.resizeDebounce,resizeDebounceDelay=_props.resizeDebounceDelay,run=_props.run,steps=_props.steps,type=_props.type;(0,_utils.logger)({type:'joyride:initialized',msg:[this.props],debug:this.props.debug});var stepsAreValid=this.checkStepsValidity(steps);if(steps&&stepsAreValid&&run)this.start(autoStart);if(resizeDebounce){(function(){var timeoutId=void 0;listeners.resize=function(){clearTimeout(timeoutId);timeoutId=setTimeout(function(){timeoutId=null;_this2.calcPlacement();},resizeDebounceDelay);};})();}else{listeners.resize=function(){_this2.calcPlacement();};}window.addEventListener('resize',listeners.resize);if(keyboardNavigation&&type==='continuous'){listeners.keyboard=this.onKeyboardNavigation;document.body.addEventListener('keydown',listeners.keyboard);}}},{key:'componentWillReceiveProps',value:function componentWillReceiveProps(nextProps){(0,_utils.logger)({type:'joyride:willReceiveProps',msg:[nextProps],debug:nextProps.debug});var _state=this.state,play=_state.play,shouldPlay=_state.shouldPlay,standaloneTooltip=_state.standaloneTooltip;var _props2=this.props,keyboardNavigation=_props2.keyboardNavigation,run=_props2.run,steps=_props2.steps,stepIndex=_props2.stepIndex;var stepsChanged=nextProps.steps!==steps;var stepIndexChanged=nextProps.stepIndex!==stepIndex&&nextProps.stepIndex!==this.state.index;var runChanged=nextProps.run!==run;var shouldStart=false;if(stepsChanged&&this.checkStepsValidity(nextProps.steps)){// Removed all steps, so reset
if(!nextProps.steps||!nextProps.steps.length){this.reset();}// Start the joyride if steps were added for the first time, and run prop is true
else if(!steps.length&&nextProps.run){shouldStart=true;}}if(runChanged){// run prop was changed to off, so stop the joyride
if(run&&nextProps.run===false){this.stop();}// run prop was changed to on, so start the joyride
else if(!run&&nextProps.run){shouldStart=true;}// Was not playing, but should, and isn't a standaloneTooltip
// TODO (@ianvs): Try moving this elsewhere, as it only relies on state, not nextProps
else if(!play&&shouldPlay&&!standaloneTooltip){shouldStart=true;}}if(stepIndexChanged){var hasStep=nextProps.steps[nextProps.stepIndex];var shouldDisplay=hasStep&&nextProps.autoStart;if(nextProps.stepIndex===0&&shouldStart){this.start(nextProps.autoStart,nextProps.steps,0);}else{this.toggleTooltip({show:shouldDisplay,index:nextProps.stepIndex,steps:nextProps.steps,action:'jump'});}}// Did not change the index, but need to start up the joyride
else if(shouldStart){this.start(nextProps.autoStart,nextProps.steps);}// Update keyboard listeners if necessary
if(!listeners.keyboard&&(!keyboardNavigation&&nextProps.keyboardNavigation||keyboardNavigation)&&nextProps.type==='continuous'){listeners.keyboard=this.onshowTooltipKeyboardNavigation;document.body.addEventListener('keydown',listeners.keyboard);}else if(listeners.keyboard&&keyboardNavigation&&(!nextProps.keyboardNavigation||nextProps.type!=='continuous')){document.body.removeEventListener('keydown',listeners.keyboard);delete listeners.keyboard;}}},{key:'componentWillUpdate',value:function componentWillUpdate(nextProps,nextState){var _state2=this.state,action=_state2.action,index=_state2.index,play=_state2.play,showTooltip=_state2.showTooltip,standaloneTooltip=_state2.standaloneTooltip;var steps=this.props.steps;var nextSteps=nextProps.steps;var step=steps[index];var nextStep=nextSteps[nextState.index];if(!standaloneTooltip&&nextState.standaloneTooltip){this.triggerCallback({type:callbackTypes.STANDALONE_BEFORE,step:nextState.standaloneTooltip});}else if(standaloneTooltip&&!nextState.standaloneTooltip){this.triggerCallback({type:callbackTypes.STANDALONE_AFTER,step:standaloneTooltip});}if(!play&&nextState.play&&index===0){this.triggerCallback({action:'start',index:index,type:callbackTypes.STEP_BEFORE,step:nextStep});if(!nextState.showTooltip){this.triggerCallback({action:'start',index:nextState.index,type:callbackTypes.BEACON_BEFORE,step:nextStep});}}if(nextState.index!==index&&play){this.triggerCallback({action:action,index:index,type:callbackTypes.STEP_AFTER,step:step});if(nextState.index&&nextStep){this.triggerCallback({action:nextState.action,index:nextState.index,type:callbackTypes.STEP_BEFORE,step:nextStep});}}if(nextState.play&&(showTooltip!==nextState.showTooltip||nextState.index!==index)){if(nextState.showTooltip){this.triggerCallback({action:nextState.action||(nextState.index===0?'autostart':''),index:nextState.index,type:callbackTypes.TOOLTIP_BEFORE,step:nextStep});}else{this.triggerCallback({action:nextState.action,index:nextState.index,type:callbackTypes.BEACON_BEFORE,step:nextStep});}}if(nextProps.run&&nextSteps.length&&!nextStep){this.triggerCallback({action:nextState.action,type:callbackTypes.FINISHED,steps:nextSteps,skipped:nextState.skipped});}}},{key:'componentDidUpdate',value:function componentDidUpdate(prevProps,prevState){var _state3=this.state,index=_state3.index,redraw=_state3.redraw,play=_state3.play,shouldPlay=_state3.shouldPlay,standaloneTooltip=_state3.standaloneTooltip;var _props3=this.props,scrollToFirstStep=_props3.scrollToFirstStep,scrollToSteps=_props3.scrollToSteps,steps=_props3.steps;var shouldScroll=scrollToFirstStep||index>0||prevState.index>index;if(redraw&&steps[index]){this.calcPlacement();}if(play&&scrollToSteps&&shouldScroll){_scroll2.default.top((0,_utils.getRootEl)(),this.getScrollTop());}if(steps.length&&!play&&shouldPlay&&!standaloneTooltip){this.start();}}},{key:'componentWillUnmount',value:function componentWillUnmount(){window.removeEventListener('resize',listeners.resize);if(listeners.keyboard){document.body.removeEventListener('keydown',listeners.keyboard);}if(Object.keys(listeners.tooltips).length){Object.keys(listeners.tooltips).forEach(function(key){document.querySelector(key).removeEventListener(listeners.tooltips[key].event,listeners.tooltips[key].cb);delete listeners.tooltips[key];});}}/**
   * Starts the tour
   *
   * @param {boolean}  [autorun]    - Starts with the first tooltip opened
   * @param {Object[]} [steps]      - Array of steps, defaults to this.props.steps
   * @param {number}   [startIndex] - Optional step index to start joyride at
   */},{key:'start',value:function start(autorun){var steps=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.props.steps;var startIndex=arguments[2];var showTooltip=autorun===true;(0,_utils.logger)({type:'joyride:start',msg:['autorun:',showTooltip],debug:this.props.debug});this.setState({play:!!steps.length,shouldPlay:!steps.length,showTooltip:showTooltip,index:typeof startIndex!=='undefined'?startIndex:this.state.index});}/**
   * Stop the tour
   */},{key:'stop',value:function stop(){(0,_utils.logger)({type:'joyride:stop',debug:this.props.debug});this.setState({showTooltip:false,play:false});}/**
   * Move to the next step, if there is one.  If there is no next step, hide the tooltip.
   */},{key:'next',value:function next(){var _state4=this.state,index=_state4.index,showTooltip=_state4.showTooltip;var steps=this.props.steps;var nextIndex=index+1;var shouldDisplay=Boolean(steps[nextIndex])&&showTooltip;(0,_utils.logger)({type:'joyride:next',msg:['new index:',nextIndex],debug:this.props.debug});this.toggleTooltip({show:shouldDisplay,index:nextIndex,action:'next'});}/**
   * Move to the previous step, if there is one.  If there is no previous step, hide the tooltip.
   */},{key:'back',value:function back(){var _state5=this.state,index=_state5.index,showTooltip=_state5.showTooltip;var steps=this.props.steps;var previousIndex=index-1;var shouldDisplay=Boolean(steps[previousIndex])&&showTooltip;(0,_utils.logger)({type:'joyride:back',msg:['new index:',previousIndex],debug:this.props.debug});this.toggleTooltip({show:shouldDisplay,index:previousIndex,action:'next'});}/**
   * Reset Tour
   *
   * @param {boolean} [restart] - Starts the new tour right away
   */},{key:'reset',value:function reset(restart){var _state6=this.state,index=_state6.index,play=_state6.play;var shouldRestart=restart===true;var newState=JSON.parse(JSON.stringify(defaultState));newState.play=shouldRestart;(0,_utils.logger)({type:'joyride:reset',msg:['restart:',shouldRestart],debug:this.props.debug});// Force a re-render if necessary
if(shouldRestart&&play===shouldRestart&&index===0){this.forceUpdate();}this.setState(newState);}/**
   * Retrieve the current progress of your tour
   *
   * @returns {{index: (number|*), percentageComplete: number, step: (object|null)}}
   */},{key:'getProgress',value:function getProgress(){var index=this.state.index;var steps=this.props.steps;(0,_utils.logger)({type:'joyride:getProgress',msg:['steps:',steps],debug:this.props.debug});return{index:index,percentageComplete:parseFloat((index/steps.length*100).toFixed(2).replace('.00','')),step:steps[index]};}/**
   * Parse the incoming steps
   *
   * @deprecated
   *
   * @param {Array|Object} steps
   * @returns {Array}
   */},{key:'parseSteps',value:function parseSteps(steps){(0,_utils.logger)({type:'joyride:parseSteps',msg:'joyride.parseSteps() is deprecated.  It is no longer necessary to parse steps before providing them to Joyride.',warn:true,debug:this.props.debug});return steps;}/**
   * Verify that a step is valid
   *
   * @param   {Object}  step - A step object
   * @returns {boolean}        True if the step is valid, false otherwise
   */},{key:'checkStepValidity',value:function checkStepValidity(step){var _this3=this;// Check that the step is the proper type
if(!step||(typeof step==='undefined'?'undefined':_typeof(step))!=='object'||Array.isArray(step)){(0,_utils.logger)({type:'joyride:checkStepValidity',msg:'Did not provide a step object.',warn:true,debug:this.props.debug});return false;}// Check that all required step fields are present
var requiredFields=['selector','text'];var hasRequiredField=function hasRequiredField(requiredField){var hasField=Boolean(step[requiredField]);if(!hasField){(0,_utils.logger)({type:'joyride:checkStepValidity',msg:['Provided a step without the required '+requiredField+' property.','Step:',step],warn:true,debug:_this3.props.debug});}return hasField;};return requiredFields.every(hasRequiredField);}/**
   * Check one or more steps are valid
   *
   * @param   {Object|Object[]}  steps - A step object or array of step objects
   * @returns {boolean}                 True if one or more stpes, and all steps are valid, false otherwise
   */},{key:'checkStepsValidity',value:function checkStepsValidity(steps){if(!Array.isArray(steps)&&(typeof steps==='undefined'?'undefined':_typeof(steps))==='object'){return this.checkStepValidity(steps);}else if(steps.length>0){return steps.every(this.checkStepValidity);}return false;}/**
   * Find and return the targeted DOM element based on a step's 'selector'.
   *
   * @param   {Object} step - A step object
   * @returns {Element}       A DOM element (if found)
   */},{key:'getStepTargetElement',value:function getStepTargetElement(step){var isValidStep=this.checkStepValidity(step);if(!isValidStep)return null;var el=document.querySelector((0,_utils.sanitizeSelector)(step.selector));if(!el){(0,_utils.logger)({type:'joyride:getStepTargetElement',msg:'Target not rendered. For best results only add steps after they are mounted.',warn:true,debug:this.props.debug});return null;}return el;}/**
   * Add standalone tooltip events
   *
   * @param {Object} data - Similar shape to a 'step', but for a single tooltip
   */},{key:'addTooltip',value:function addTooltip(data){if(!this.checkStepValidity(data))return;(0,_utils.logger)({type:'joyride:addTooltip',msg:['data:',data],debug:this.props.debug});var key=data.trigger||(0,_utils.sanitizeSelector)(data.selector);var el=document.querySelector(key);if(!el)return;el.setAttribute('data-tooltip',JSON.stringify(data));var eventType=data.event||'click';if(eventType==='hover'&&!isTouch){listeners.tooltips[key]={event:'mouseenter',cb:this.onClickStandaloneTrigger};listeners.tooltips[key+'mouseleave']={event:'mouseleave',cb:this.onClickStandaloneTrigger};listeners.tooltips[key+'click']={event:'click',cb:function cb(e){e.preventDefault();}};el.addEventListener('mouseenter',listeners.tooltips[key].cb);el.addEventListener('mouseleave',listeners.tooltips[key+'mouseleave'].cb);el.addEventListener('click',listeners.tooltips[key+'click'].cb);}else{listeners.tooltips[key]={event:'click',cb:this.onClickStandaloneTrigger};el.addEventListener('click',listeners.tooltips[key].cb);}}/**
   * Get an element actual dimensions with margin
   *
   * @private
   * @param {String|Element} el - Element node or selector
   * @returns {{height: number, width: number}}
   */},{key:'getElementDimensions',value:function getElementDimensions(el){// Get the DOM Node if you pass in a string
var newEl=typeof el==='string'?document.querySelector(el):el;var height=0;var width=0;if(newEl){var styles=window.getComputedStyle(newEl);height=newEl.clientHeight+parseInt(styles.marginTop,10)+parseInt(styles.marginBottom,10);width=newEl.clientWidth+parseInt(styles.marginLeft,10)+parseInt(styles.marginRight,10);}return{height:height,width:width};}/**
   * Get the scrollTop position
   *
   * @private
   * @returns {number}
   */},{key:'getScrollTop',value:function getScrollTop(){var _state7=this.state,index=_state7.index,yPos=_state7.yPos;var _props4=this.props,scrollOffset=_props4.scrollOffset,steps=_props4.steps;var step=steps[index];var target=this.getStepTargetElement(step);if(!target){return 0;}var rect=target.getBoundingClientRect();var targetTop=rect.top+(window.pageYOffset||document.documentElement.scrollTop);var position=this.calcPosition(step);var scrollTo=0;if(/^top/.test(position)){scrollTo=Math.floor(yPos-scrollOffset);}else if(/^bottom|^left|^right/.test(position)){scrollTo=Math.floor(targetTop-scrollOffset);}return scrollTo;}},{key:'triggerCallback',value:function triggerCallback(options){var callback=this.props.callback;if(typeof callback==='function'){callback(options);}}/**
   * Keydown event listener
   *
   * @private
   * @param {Event} e - Keyboard event
   */},{key:'onKeyboardNavigation',value:function onKeyboardNavigation(e){var _state8=this.state,index=_state8.index,showTooltip=_state8.showTooltip;var steps=this.props.steps;var intKey=window.Event?e.which:e.keyCode;var hasSteps=void 0;if(showTooltip){if([32,38,40].indexOf(intKey)>-1){e.preventDefault();}if(intKey===27){this.toggleTooltip({show:false,index:index+1,action:'esc'});}else if([13,32].indexOf(intKey)>-1){hasSteps=Boolean(steps[index+1]);this.toggleTooltip({show:hasSteps,index:index+1,action:'next'});}}}/**
   * Tooltip event listener
   *
   * @private
   * @param {Event} e - Click event
   */},{key:'onClickStandaloneTrigger',value:function onClickStandaloneTrigger(e){e.preventDefault();var _state9=this.state,play=_state9.play,shouldPlay=_state9.shouldPlay,standaloneTooltip=_state9.standaloneTooltip;var tooltipData=e.currentTarget.dataset.tooltip;if(tooltipData){tooltipData=JSON.parse(tooltipData);if(!standaloneTooltip||standaloneTooltip.selector!==tooltipData.selector){this.setState({shouldPlay:shouldPlay!==undefined?shouldPlay:play,play:false,showTooltip:false,position:undefined,standaloneTooltip:tooltipData,xPos:-1000,yPos:-1000});}else{document.querySelector('.joyride-tooltip__close').click();}}}},{key:'onRenderTooltip',value:function onRenderTooltip(){this.calcPlacement();}/**
   * Beacon click event listener
   *
   * @private
   * @param {Event} e - Click event
   */},{key:'onClickBeacon',value:function onClickBeacon(e){e.preventDefault();var index=this.state.index;var steps=this.props.steps;this.triggerCallback({action:e.type,index:index,type:callbackTypes.BEACON_TRIGGER,step:steps[index]});this.toggleTooltip({show:true,index:index,action:'beacon:'+e.type});}/**
   * Tooltip click event listener
   *
   * @private
   * @param {Event} e - Click event
   */},{key:'onClickTooltip',value:function onClickTooltip(e){var _state10=this.state,index=_state10.index,shouldPlay=_state10.shouldPlay;var _props5=this.props,steps=_props5.steps,type=_props5.type;var el=e.currentTarget.className.indexOf('joyride-')===0&&e.currentTarget.tagName==='A'?e.currentTarget:e.target;var dataType=el.dataset.type;if(el.className.indexOf('joyride-')===0){e.preventDefault();e.stopPropagation();var tooltip=document.querySelector('.joyride-tooltip');var newIndex=index+(dataType==='back'?-1:1);if(dataType==='skip'){this.setState({skipped:true});newIndex=steps.length+1;}if(tooltip.classList.contains('joyride-tooltip--standalone')){this.setState({play:shouldPlay,shouldPlay:undefined,standaloneTooltip:undefined,redraw:true});}else if(dataType){var shouldDisplay=['continuous','guided'].indexOf(type)>-1&&['close','skip'].indexOf(dataType)===-1&&Boolean(steps[newIndex]);this.toggleTooltip({show:shouldDisplay,index:newIndex,action:dataType});}if(e.target.className==='joyride-overlay'){this.triggerCallback({action:'click',type:callbackTypes.OVERLAY,step:steps[index]});}if(e.target.classList.contains('joyride-hole')){this.triggerCallback({action:'click',type:callbackTypes.HOLE,step:steps[index]});}}}/**
   * Toggle Tooltip's visibility
   *
   * @private
   * @param {Object}    [arg]        - Immediately destructured argument object
   * @param {Boolean}   [arg.show]   - Render the tooltip or the beacon, defaults to opposite of current show
   * @param {Number}    [arg.index]  - The tour's new index, defaults to current index
   * @param {string}    [arg.action] - The action being undertaken.
   * @param {Object[]}  [arg.steps]  - The array of step objects that is going to be rendered
   */},{key:'toggleTooltip',value:function toggleTooltip(_ref){var _ref$show=_ref.show,show=_ref$show===undefined?!this.state.showTooltip:_ref$show,_ref$index=_ref.index,index=_ref$index===undefined?this.state.index:_ref$index,_ref$action=_ref.action,action=_ref$action===undefined?'':_ref$action,_ref$steps=_ref.steps,steps=_ref$steps===undefined?this.props.steps:_ref$steps;var nextIndex=index;var nextStep=steps[nextIndex];if(nextStep&&!this.getStepTargetElement(nextStep)){console.warn('Target not mounted, skipping...',nextStep,action);//eslint-disable-line no-console
nextIndex+=action==='back'?-1:1;}this.setState({action:action,play:nextStep?this.state.play:false,// stop playing if there is no next step
showTooltip:show,index:nextIndex,redraw:!show,xPos:-1000,yPos:-1000});}/**
   * Position absolute elements next to its target
   *
   * @private
   */},{key:'calcPlacement',value:function calcPlacement(){var _state11=this.state,index=_state11.index,play=_state11.play,standaloneTooltip=_state11.standaloneTooltip,showTooltip=_state11.showTooltip;var _props6=this.props,steps=_props6.steps,tooltipOffset=_props6.tooltipOffset;var step=standaloneTooltip||steps[index]||{};(0,_utils.logger)({type:'joyride:calcPlacement'+this.getRenderStage(),msg:['step:',step],debug:this.props.debug});var displayTooltip=standaloneTooltip?true:showTooltip;var target=this.getStepTargetElement(step);if(!target){this.setState({redraw:false});return;}var placement={x:-1000,y:-1000};if(step&&(standaloneTooltip||play&&steps[index])){var offsetX=_nestedProperty2.default.get(step,'style.beacon.offsetX')||0;var offsetY=_nestedProperty2.default.get(step,'style.beacon.offsetY')||0;var position=this.calcPosition(step);var body=document.body.getBoundingClientRect();var component=this.getElementDimensions(displayTooltip?'.joyride-tooltip':'.joyride-beacon');var rect=target.getBoundingClientRect();// Calculate x position
if(/^left/.test(position)){placement.x=rect.left-(displayTooltip?component.width+tooltipOffset:component.width/2+offsetX);}else if(/^right/.test(position)){placement.x=rect.left+rect.width-(displayTooltip?-tooltipOffset:component.width/2-offsetX);}else{placement.x=rect.left+(rect.width/2-component.width/2);}// Calculate y position
if(/^top/.test(position)){placement.y=rect.top-body.top-(displayTooltip?component.height+tooltipOffset:component.height/2+offsetY);}else if(/^bottom/.test(position)){placement.y=rect.top-body.top+(rect.height-(displayTooltip?-tooltipOffset:component.height/2-offsetY));}else{placement.y=rect.top-body.top;}if(/^bottom|^top/.test(position)){if(/left/.test(position)){placement.x=rect.left-(displayTooltip?tooltipOffset:component.width/2);}else if(/right/.test(position)){placement.x=rect.left+(rect.width-(displayTooltip?component.width-tooltipOffset:component.width/2));}}this.setState({xPos:this.preventWindowOverflow(Math.ceil(placement.x),'x',component.width,component.height),yPos:this.preventWindowOverflow(Math.ceil(placement.y),'y',component.width,component.height),redraw:false});}}/**
   * Update position for small screens.
   *
   * @private
   * @param {Object} step
   *
   * @returns {string}
   */},{key:'calcPosition',value:function calcPosition(step){var _state12=this.state,showTooltip=_state12.showTooltip,standaloneTooltip=_state12.standaloneTooltip;var tooltipOffset=this.props.tooltipOffset;var displayTooltip=standaloneTooltip?true:showTooltip;var body=document.body.getBoundingClientRect();var target=this.getStepTargetElement(step);var component=this.getElementDimensions(displayTooltip?'.joyride-tooltip':'.joyride-beacon');var rect=target.getBoundingClientRect();var position=step.position||STEP_DEFAULTS.position;if(/^left/.test(position)&&rect.left-(component.width+tooltipOffset)<0){position='top';}else if(/^right/.test(position)&&rect.left+rect.width+(component.width+tooltipOffset)>body.width){position='bottom';}return position;}},{key:'getRenderStage',value:function getRenderStage(){var _state13=this.state,redraw=_state13.redraw,xPos=_state13.xPos;if(redraw){return':redraw';}else if(xPos<0){return':pre-render';}return'';}/**
   * Prevent tooltip to render outside the window
   *
   * @private
   * @param {Number} value - The axis position
   * @param {String} axis - The Axis X or Y
   * @param {Number} elWidth - The target element width
   * @param {Number} elHeight - The target element height
   * @returns {Number}
   */},{key:'preventWindowOverflow',value:function preventWindowOverflow(value,axis,elWidth,elHeight){var winWidth=window.innerWidth;var body=document.body;var html=document.documentElement;var docHeight=Math.max(body.scrollHeight,body.offsetHeight,html.clientHeight,html.scrollHeight,html.offsetHeight);var newValue=value;if(axis==='x'){if(value+elWidth>=winWidth){newValue=winWidth-elWidth-15;}else if(value<15){newValue=15;}}else if(axis==='y'){if(value+elHeight>=docHeight){newValue=docHeight-elHeight-15;}else if(value<15){newValue=15;}}return newValue;}/**
   * Create a React Element
   *
   * @private
   * @returns {*}
   */},{key:'createComponent',value:function createComponent(){var _state14=this.state,index=_state14.index,redraw=_state14.redraw,showTooltip=_state14.showTooltip,standaloneTooltip=_state14.standaloneTooltip,xPos=_state14.xPos,yPos=_state14.yPos;var _props7=this.props,disableOverlay=_props7.disableOverlay,holePadding=_props7.holePadding,locale=_props7.locale,showBackButton=_props7.showBackButton,showOverlay=_props7.showOverlay,showSkipButton=_props7.showSkipButton,showStepsProgress=_props7.showStepsProgress,steps=_props7.steps,type=_props7.type;var currentStep=standaloneTooltip||steps[index];var step=_extends({},currentStep);var target=this.getStepTargetElement(step);var cssPosition=target?target.style.position:null;var shouldShowOverlay=standaloneTooltip?false:showOverlay;var buttons={primary:locale.close};var component=void 0;(0,_utils.logger)({type:'joyride:createComponent'+this.getRenderStage(),msg:['component:',showTooltip||standaloneTooltip?'Tooltip':'Beacon','animate:',xPos>-1&&!redraw,'step:',step],debug:this.props.debug,warn:!target});if(!target){return false;}if(showTooltip||standaloneTooltip){var position=this.calcPosition(step);if(!standaloneTooltip){if(['continuous','guided'].indexOf(type)>-1){buttons.primary=locale.last;if(steps[index+1]){if(showStepsProgress){var next=locale.next;if(typeof locale.next==='string'){next=_react2.default.createElement('span',null,locale.next);}buttons.primary=_react2.default.createElement('span',null,next,' ',_react2.default.createElement('span',null,index+1+'/'+steps.length));}else{buttons.primary=locale.next;}}if(showBackButton&&index>0){buttons.secondary=locale.back;}}if(showSkipButton){buttons.skip=locale.skip;}}component=_react2.default.createElement(_Tooltip2.default,{animate:xPos>-1&&!redraw,buttons:buttons,cssPosition:cssPosition,disableOverlay:disableOverlay,holePadding:holePadding,position:position,selector:(0,_utils.sanitizeSelector)(step.selector),showOverlay:shouldShowOverlay,step:step,standalone:Boolean(standaloneTooltip),target:target,type:type,xPos:xPos,yPos:yPos,onClick:this.onClickTooltip,onRender:this.onRenderTooltip});}else{component=_react2.default.createElement(_Beacon2.default,{cssPosition:cssPosition,step:step,xPos:xPos,yPos:yPos,onTrigger:this.onClickBeacon,eventType:step.type||'click'});}return component;}},{key:'render',value:function render(){var _state15=this.state,index=_state15.index,play=_state15.play,standaloneTooltip=_state15.standaloneTooltip;var steps=this.props.steps;var hasStep=Boolean(steps[index]);var component=void 0;var standaloneComponent=void 0;if(play&&hasStep){(0,_utils.logger)({type:'joyride:render'+this.getRenderStage(),msg:['step:',steps[index]],debug:this.props.debug});}else if(!play&&standaloneTooltip){(0,_utils.logger)({type:'joyride:render',msg:['tooltip:',standaloneTooltip],debug:this.props.debug});}if(standaloneTooltip){standaloneComponent=this.createComponent();}else if(play&&hasStep){component=this.createComponent();}return _react2.default.createElement('div',{className:'joyride'},component,standaloneComponent);}}]);return Joyride;}(_react2.default.Component),_class.propTypes={autoStart:_react2.default.PropTypes.bool,callback:_react2.default.PropTypes.func,debug:_react2.default.PropTypes.bool,disableOverlay:_react2.default.PropTypes.bool,holePadding:_react2.default.PropTypes.number,keyboardNavigation:_react2.default.PropTypes.bool,locale:_react2.default.PropTypes.object,resizeDebounce:_react2.default.PropTypes.bool,resizeDebounceDelay:_react2.default.PropTypes.number,run:_react2.default.PropTypes.bool,scrollOffset:_react2.default.PropTypes.number,scrollToFirstStep:_react2.default.PropTypes.bool,scrollToSteps:_react2.default.PropTypes.bool,showBackButton:_react2.default.PropTypes.bool,showOverlay:_react2.default.PropTypes.bool,showSkipButton:_react2.default.PropTypes.bool,showStepsProgress:_react2.default.PropTypes.bool,stepIndex:_react2.default.PropTypes.number,steps:_react2.default.PropTypes.array,tooltipOffset:_react2.default.PropTypes.number,type:_react2.default.PropTypes.string},_class.defaultProps={autoStart:false,debug:false,holePadding:5,keyboardNavigation:true,locale:{back:'Back',close:'Close',last:'Last',next:'Next',skip:'Skip'},resizeDebounce:false,resizeDebounceDelay:200,run:false,scrollToSteps:true,scrollOffset:20,scrollToFirstStep:false,showBackButton:true,showOverlay:true,showSkipButton:false,showStepsProgress:false,steps:[],tooltipOffset:15,type:'single'},_temp);exports.default=Joyride;