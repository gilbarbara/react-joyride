'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _class,_temp;var _react=require('react');var _react2=_interopRequireDefault(_react);var _scroll=require('scroll');var _scroll2=_interopRequireDefault(_scroll);var _reactAutobind=require('react-autobind');var _reactAutobind2=_interopRequireDefault(_reactAutobind);var _nestedProperty=require('nested-property');var _nestedProperty2=_interopRequireDefault(_nestedProperty);var _utils=require('./utils');var _Beacon=require('./Beacon');var _Beacon2=_interopRequireDefault(_Beacon);var _Tooltip=require('./Tooltip');var _Tooltip2=_interopRequireDefault(_Tooltip);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var defaultState={action:'',index:0,play:false,redraw:true,shouldPlay:false,showTooltip:false,xPos:-1000,yPos:-1000,skipped:false};var callbackTypes={STEP_BEFORE:'step:before',BEACON_BEFORE:'beacon:before',BEACON_TRIGGER:'beacon:trigger',TOOLTIP_BEFORE:'tooltip:before',STEP_AFTER:'step:after',STANDALONE_BEFORE:'standalone:before',STANDALONE_AFTER:'standalone:after',OVERLAY:'overlay:click',HOLE:'hole:click',FINISHED:'finished'};var listeners={tooltips:{}};var isTouch=false;if(typeof window!=='undefined'){isTouch='ontouchstart'in window||navigator.msMaxTouchPoints;}var Joyride=(_temp=_class=function(_React$Component){_inherits(Joyride,_React$Component);function Joyride(props){_classCallCheck(this,Joyride);var _this=_possibleConstructorReturn(this,(Joyride.__proto__||Object.getPrototypeOf(Joyride)).call(this,props));(0,_reactAutobind2.default)(_this);_this.state=defaultState;return _this;}_createClass(Joyride,[{key:'componentDidMount',value:function componentDidMount(){var _this2=this;var _props=this.props,keyboardNavigation=_props.keyboardNavigation,resizeDebounce=_props.resizeDebounce,resizeDebounceDelay=_props.resizeDebounceDelay,type=_props.type;this.logger('joyride:initialized',[this.props]);if(resizeDebounce){(function(){var timeoutId=void 0;listeners.resize=function(){clearTimeout(timeoutId);timeoutId=setTimeout(function(){timeoutId=null;_this2.calcPlacement();},resizeDebounceDelay);};})();}else{listeners.resize=function(){_this2.calcPlacement();};}window.addEventListener('resize',listeners.resize);if(keyboardNavigation&&type==='continuous'){listeners.keyboard=this.onKeyboardNavigation;document.body.addEventListener('keydown',listeners.keyboard);}}},{key:'componentWillReceiveProps',value:function componentWillReceiveProps(nextProps){var _state=this.state,play=_state.play,shouldPlay=_state.shouldPlay,standaloneTooltip=_state.standaloneTooltip;var _props2=this.props,keyboardNavigation=_props2.keyboardNavigation,run=_props2.run;this.logger('joyride:willReceiveProps',[nextProps]);if(!nextProps.steps.length){this.reset();}if(!run&&nextProps.run||!play&&shouldPlay&&!standaloneTooltip){this.start();}if(run&&!nextProps.run){this.stop();}if(!listeners.keyboard&&(!keyboardNavigation&&nextProps.keyboardNavigation||keyboardNavigation)&&nextProps.type==='continuous'){listeners.keyboard=this.onshowTooltipKeyboardNavigation;document.body.addEventListener('keydown',listeners.keyboard);}else if(listeners.keyboard&&keyboardNavigation&&(!nextProps.keyboardNavigation||nextProps.type!=='continuous')){document.body.removeEventListener('keydown',listeners.keyboard);delete listeners.keyboard;}}},{key:'componentWillUpdate',value:function componentWillUpdate(nextProps,nextState){var _state2=this.state,action=_state2.action,index=_state2.index,play=_state2.play,showTooltip=_state2.showTooltip,standaloneTooltip=_state2.standaloneTooltip;var steps=this.props.steps;var step=steps[index];var nextStep=steps[nextState.index];if(!standaloneTooltip&&nextState.standaloneTooltip){this.triggerCallback({type:callbackTypes.STANDALONE_BEFORE,step:nextState.standaloneTooltip});}else if(standaloneTooltip&&!nextState.standaloneTooltip){this.triggerCallback({type:callbackTypes.STANDALONE_AFTER,step:standaloneTooltip});}if(!play&&nextState.play&&index===0){this.triggerCallback({action:'start',index:index,type:callbackTypes.STEP_BEFORE,step:nextStep});if(!nextState.showTooltip){this.triggerCallback({action:'start',index:nextState.index,type:callbackTypes.BEACON_BEFORE,step:nextStep});}}if(nextState.index!==index){this.triggerCallback({action:action,index:index,type:callbackTypes.STEP_AFTER,step:step});if(nextState.index&&nextStep){this.triggerCallback({action:nextState.action,index:nextState.index,type:callbackTypes.STEP_BEFORE,step:nextStep});}}if(nextState.play&&(showTooltip!==nextState.showTooltip||nextState.index!==index)){if(nextState.showTooltip){this.triggerCallback({action:nextState.action||(nextState.index===0?'autostart':''),index:nextState.index,type:callbackTypes.TOOLTIP_BEFORE,step:nextStep});}else{this.triggerCallback({action:nextState.action,index:nextState.index,type:callbackTypes.BEACON_BEFORE,step:nextStep});}}if(steps.length&&!steps[nextState.index]&&nextState.index!==index){this.triggerCallback({action:nextState.action,type:callbackTypes.FINISHED,steps:steps,skipped:nextState.skipped});}}},{key:'componentDidUpdate',value:function componentDidUpdate(prevProps,prevState){var _state3=this.state,index=_state3.index,redraw=_state3.redraw,play=_state3.play,shouldPlay=_state3.shouldPlay,standaloneTooltip=_state3.standaloneTooltip;var _props3=this.props,scrollToFirstStep=_props3.scrollToFirstStep,scrollToSteps=_props3.scrollToSteps,steps=_props3.steps,scrollContainerSelector=_props3.scrollContainerSelector;var shouldScroll=scrollToFirstStep||index!==0&&prevState.index!==index;var step=steps[index];var useScrollContainer=step&&step.scrollContainerSelector||scrollContainerSelector;if(play&&scrollToSteps&&shouldScroll){if(useScrollContainer&&this.getScrollContainer(useScrollContainer)){// Scroll specified parent element
this.scrollContainerElement(useScrollContainer);}else{// Scroll body element
this.scrollBodyElement();}}else if(redraw){this.calcPlacement();}if(steps.length&&!play&&shouldPlay&&!standaloneTooltip){this.start();}}},{key:'componentWillUnmount',value:function componentWillUnmount(){window.removeEventListener('resize',listeners.resize);if(listeners.keyboard){document.body.removeEventListener('keydown',listeners.keyboard);}if(Object.keys(listeners.tooltips).length){Object.keys(listeners.tooltips).forEach(function(key){document.querySelector(key).removeEventListener(listeners.tooltips[key].event,listeners.tooltips[key].cb);delete listeners.tooltips[key];});}}/**
   * Scrolls the body element to correct top and left position
   *
   * @param {Boolean} [forceRedraw] - If redraw should be force executed
   */},{key:'scrollBodyElement',value:function scrollBodyElement(forceRedraw){var _this3=this;clearTimeout(this.bodyScrollTimeout);this.bodyScrollTimeout=setTimeout(function(){_this3.bodyScrollTimeout=null;if(forceRedraw||_this3.state.redraw){_this3.calcPlacement();}_scroll2.default.top(_this3.getScrollContainer(),_this3.getScrollValue(false,'y'));_scroll2.default.left(_this3.getScrollContainer(),_this3.getScrollValue(false,'x'));},10);}/**
   * Scrolls the scrollContainerSelector element to correct top and left position
   *
   * @param {String} [useScrollContainer] - The step or app-level scroll container selector
   */},{key:'scrollContainerElement',value:function scrollContainerElement(useScrollContainer){var _this4=this;var state=this.state;var steps=this.props.steps;var step=steps[state.index];var target=document.querySelector(step.selector);if(!target||!useScrollContainer){return;}var scrollContainerElem=this.getScrollContainer(useScrollContainer);var containerOffsetTop=scrollContainerElem.scrollTop;var containerOffsetLeft=scrollContainerElem.scrollLeft;var newYScroll=this.getScrollValue(true,'y');var newXScroll=this.getScrollValue(true,'x');if(containerOffsetTop!==newYScroll&&containerOffsetLeft!==newXScroll){_scroll2.default.top(scrollContainerElem,newYScroll,{duration:1},function(){_scroll2.default.left(scrollContainerElem,newXScroll,{duration:1},function(){// Adjust body scroll after scroll container has been scrolled and position is recalculated
_this4.calcPlacement(_this4.scrollBodyElement.bind(null,true));});});}else if(containerOffsetTop!==newYScroll){_scroll2.default.top(scrollContainerElem,newYScroll,{duration:1},function(){// Adjust body scroll after scroll container has been scrolled and position is recalculated
_this4.calcPlacement(_this4.scrollBodyElement.bind(null,true));});}else if(containerOffsetLeft!==newXScroll){_scroll2.default.left(scrollContainerElem,newXScroll,{duration:1},function(){// Adjust body scroll after scroll container has been scrolled and position is recalculated
_this4.calcPlacement(_this4.scrollBodyElement.bind(null,true));});}else{this.scrollBodyElement();}}/**
   * Starts the tour
   *
   * @param {boolean} [autorun]- Starts with the first tooltip opened
   */},{key:'start',value:function start(autorun){var showTooltip=autorun===true;var steps=this.props.steps;this.logger('joyride:start',['autorun:',showTooltip]);this.setState({play:!!steps.length,shouldPlay:!steps.length,showTooltip:showTooltip});}/**
   * Stop the tour
   */},{key:'stop',value:function stop(){this.logger('joyride:stop');this.setState({showTooltip:false,play:false});}/**
   * Move to the next step, if there is one.  If there is no next step, hide the tooltip.
   */},{key:'next',value:function next(){var _state4=this.state,index=_state4.index,showTooltip=_state4.showTooltip;var steps=this.props.steps;var nextIndex=index+1;var shouldDisplay=Boolean(steps[nextIndex])&&showTooltip;this.logger('joyride:next',['new index:',nextIndex]);this.toggleTooltip(shouldDisplay,nextIndex,'next');}/**
   * Move to the previous step, if there is one.  If there is no previous step, hide the tooltip.
   */},{key:'back',value:function back(){var _state5=this.state,index=_state5.index,showTooltip=_state5.showTooltip;var steps=this.props.steps;var previousIndex=index-1;var shouldDisplay=Boolean(steps[previousIndex])&&showTooltip;this.logger('joyride:back',['new index:',previousIndex]);this.toggleTooltip(shouldDisplay,previousIndex,'next');}/**
   * Reset Tour
   *
   * @param {boolean} [restart] - Starts the new tour right away
   */},{key:'reset',value:function reset(restart){var _state6=this.state,index=_state6.index,play=_state6.play;var shouldRestart=restart===true;var newState=JSON.parse(JSON.stringify(defaultState));newState.play=shouldRestart;this.logger('joyride:reset',['restart:',shouldRestart]);// Force a re-render if necessary
if(shouldRestart&&play===shouldRestart&&index===0){this.forceUpdate();}this.setState(newState);}/**
   * Retrieve the current progress of your tour
   *
   * @returns {{index: (number|*), percentageComplete: number, step: (object|null)}}
   */},{key:'getProgress',value:function getProgress(){var index=this.state.index;var steps=this.props.steps;this.logger('joyride:getProgress',['steps:',steps]);return{index:index,percentageComplete:parseFloat((index/steps.length*100).toFixed(2).replace('.00','')),step:steps[index]};}/**
   * Parse the incoming steps
   *
   * @param {Array|Object} steps
   * @returns {Array}
   */},{key:'parseSteps',value:function parseSteps(steps){var _this5=this;var newSteps=[];var tmpSteps=[];var el=void 0;if(Array.isArray(steps)){steps.forEach(function(s){if(s instanceof Object){tmpSteps.push(s);}});}else{tmpSteps=[steps];}tmpSteps.forEach(function(s){if(s.selector.dataset&&s.selector.dataset.reactid){s.selector='[data-reactid="'+s.selector.dataset.reactid+'"]';console.warn('Deprecation warning: React 15.0 removed reactid. Update your code.');//eslint-disable-line no-console
}else if(s.selector.dataset){console.error('Unsupported error: React 15.0+ don\'t write reactid to the DOM anymore, please use a plain class in your step.',s);//eslint-disable-line no-console
if(s.selector.className){s.selector='.'+s.selector.className.replace(' ','.');}}el=document.querySelector(s.selector);s.position=s.position||'top';newSteps.push(s);if(!el){_this5.logger('joyride:parseSteps','Target not rendered. For best results only add steps after they are mounted.',s);}});return newSteps;}/**
   * Add Tooltip events
   *
   * @param {Object} data
   */},{key:'addTooltip',value:function addTooltip(data){var parseData=this.parseSteps(data);var newData=void 0;var el=void 0;var eventType=void 0;var key=void 0;this.logger('joyride:addTooltip',['data:',data]);if(parseData.length){newData=parseData[0];key=newData.trigger||newData.selector;el=document.querySelector(key);eventType=newData.event||'click';}if(!el){return;}el.setAttribute('data-tooltip',JSON.stringify(data));if(eventType==='hover'&&!isTouch){listeners.tooltips[key]={event:'mouseenter',cb:this.onClickStandaloneTrigger};listeners.tooltips[key+'mouseleave']={event:'mouseleave',cb:this.onClickStandaloneTrigger};listeners.tooltips[key+'click']={event:'click',cb:function cb(e){e.preventDefault();}};el.addEventListener('mouseenter',listeners.tooltips[key].cb);el.addEventListener('mouseleave',listeners.tooltips[key+'mouseleave'].cb);el.addEventListener('click',listeners.tooltips[key+'click'].cb);}else{listeners.tooltips[key]={event:'click',cb:this.onClickStandaloneTrigger};el.addEventListener('click',listeners.tooltips[key].cb);}}/**
   * Log method calls if debug is enabled
   *
   * @private
   * @param {string} type
   * @param {string|Array} [msg]
   * @param {boolean} [warn]
   */},{key:'logger',value:function logger(type,msg,warn){var debug=this.props.debug;var logger=warn?console.warn||console.error:console.log;//eslint-disable-line no-console
if(debug){console.log('%c'+type,'color: #760bc5; font-weight: bold; font-size: 12px;');//eslint-disable-line no-console
if(msg){logger.apply(console,msg);}}}/**
   * Get the scroll container
   * @param {String} scrollContainer - The scrollable parent container selector
   * @param {Element} defaultElement - Element node
   * @returns {Element} Element node
   */},{key:'getScrollContainer',value:function getScrollContainer(scrollContainer,defaultElement){return(0,_utils.getScrollContainer)(scrollContainer,defaultElement);}/**
   * Get an element actual dimensions with margin
   *
   * @private
   * @param {String|Element} el - Element node or selector
   * @returns {{height: number, width: number}}
   */},{key:'getElementDimensions',value:function getElementDimensions(el){// Get the DOM Node if you pass in a string
var newEl=typeof el==='string'?document.querySelector(el):el;var height=0;var width=0;if(newEl){var styles=window.getComputedStyle(newEl);height=newEl.clientHeight+parseInt(styles.marginTop,10)+parseInt(styles.marginBottom,10);width=newEl.clientWidth+parseInt(styles.marginLeft,10)+parseInt(styles.marginRight,10);}return{height:height,width:width};}/**
   * Get the scrollTop position
   *
   * @private
   * @param {Boolean} getContainerScroll - If obtaining the scrollContainerSelector scroll position (as opposed to the body scroll position)
   * @param {String} axis - The axis to get the scroll value, 'y' or 'x'
   * @returns {number}
   */},{key:'getScrollValue',value:function getScrollValue(getContainerScroll,axis){var _state7=this.state,index=_state7.index,yPos=_state7.yPos;var _props4=this.props,scrollOffset=_props4.scrollOffset,steps=_props4.steps,scrollContainerSelector=_props4.scrollContainerSelector;var step=steps[index];var target=step&&document.querySelector(step.selector);if(!target){return 0;}var useScrollContainer=step&&step.scrollContainerSelector||scrollContainerSelector;var scrollContainerElem=this.getScrollContainer(useScrollContainer);var scrollPosFields=this.getScrollPosFields(axis);var containerOffset=scrollContainerElem[scrollPosFields.scrollField];var rect=target.getBoundingClientRect();var offsetPos=window[scrollPosFields.pageOffset]||document.documentElement[scrollPosFields.scrollField];if(getContainerScroll){if(!useScrollContainer){return 0;}if(step&&step.scrollContainerSelector){return this.getScrollForParentContainer(axis);}offsetPos=containerOffset;}// Add the target offset
var scrollTo=offsetPos+rect[scrollPosFields.start];// Only add viewport offset if scrolling vertically for parent or body
if(axis==='y'&&(!getContainerScroll||!step.scrollContainerSelector)){var position=this.calcPosition(step);if(/^top/.test(position)){scrollTo=yPos-scrollOffset;}else if(/^bottom|^left|^right/.test(position)){scrollTo-=scrollOffset;}}return Math.floor(scrollTo);}},{key:'getScrollPosFields',value:function getScrollPosFields(axis){return{start:axis==='y'?'top':'left',end:axis==='y'?'bottom':'right',scrollField:'scroll'+(axis==='y'?'Top':'Left'),pageOffset:'page'+(axis==='y'?'Y':'X')+'Offset',paddingStart:'padding'+(axis==='y'?'Top':'Left'),paddingEnd:'padding'+(axis==='y'?'Bottom':'Right')};}},{key:'getScrollForParentContainer',value:function getScrollForParentContainer(axis){var index=this.state.index;var _props5=this.props,steps=_props5.steps,scrollContainerSelector=_props5.scrollContainerSelector;var step=steps[index];var target=document.querySelector(step.selector);var rect=target.getBoundingClientRect();var useScrollContainer=step&&step.scrollContainerSelector||scrollContainerSelector;var scrollContainerElem=this.getScrollContainer(useScrollContainer);var scrollPosFields=this.getScrollPosFields(axis);var containerOffset=scrollContainerElem[scrollPosFields.scrollField];var containerRect=scrollContainerElem.getBoundingClientRect();var computedStyle=getComputedStyle(scrollContainerElem);var containerPaddingOffset=parseFloat(computedStyle[scrollPosFields.paddingStart]);var scrollbarWidth=scrollContainerElem.offsetWidth-scrollContainerElem.clientWidth;// Target is out of view, scroll container so it's fully visible
if(rect[scrollPosFields.end]>containerRect[scrollPosFields.end]){return Math.floor(rect[scrollPosFields.end]-containerRect[scrollPosFields.end]+containerPaddingOffset+scrollbarWidth+containerOffset);}else if(rect[scrollPosFields.start]<containerRect[scrollPosFields.start]){return Math.floor(containerOffset-Math.abs(rect[scrollPosFields.start])-containerRect[scrollPosFields.start]-scrollbarWidth);}return containerOffset;}},{key:'triggerCallback',value:function triggerCallback(options){var callback=this.props.callback;if(typeof callback==='function'){callback(options);}}/**
   * Keydown event listener
   *
   * @private
   * @param {Event} e - Keyboard event
   */},{key:'onKeyboardNavigation',value:function onKeyboardNavigation(e){var _state8=this.state,index=_state8.index,showTooltip=_state8.showTooltip;var steps=this.props.steps;var intKey=window.Event?e.which:e.keyCode;var hasSteps=void 0;if(showTooltip){if([32,38,40].indexOf(intKey)>-1){e.preventDefault();}if(intKey===27){this.toggleTooltip(false,index+1,'esc');}else if([13,32].indexOf(intKey)>-1){hasSteps=Boolean(steps[index+1]);this.toggleTooltip(hasSteps,index+1,'next');}}}/**
   * Tooltip event listener
   *
   * @private
   * @param {Event} e - Click event
   */},{key:'onClickStandaloneTrigger',value:function onClickStandaloneTrigger(e){e.preventDefault();var _state9=this.state,play=_state9.play,shouldPlay=_state9.shouldPlay,standaloneTooltip=_state9.standaloneTooltip;var tooltipData=e.currentTarget.dataset.tooltip;if(tooltipData){tooltipData=JSON.parse(tooltipData);if(!standaloneTooltip||standaloneTooltip.selector!==tooltipData.selector){this.setState({shouldPlay:shouldPlay!==undefined?shouldPlay:play,play:false,showTooltip:false,position:undefined,standaloneTooltip:tooltipData,xPos:-1000,yPos:-1000});}else{document.querySelector('.joyride-tooltip__close').click();}}}},{key:'onRenderTooltip',value:function onRenderTooltip(){this.calcPlacement();}/**
   * Beacon click event listener
   *
   * @private
   * @param {Event} e - Click event
   */},{key:'onClickBeacon',value:function onClickBeacon(e){e.preventDefault();var index=this.state.index;var steps=this.props.steps;this.triggerCallback({action:e.type,index:index,type:callbackTypes.BEACON_TRIGGER,step:steps[index]});this.toggleTooltip(true,index,'beacon:'+e.type);}/**
   * Tooltip click event listener
   *
   * @private
   * @param {Event} e - Click event
   */},{key:'onClickTooltip',value:function onClickTooltip(e){var _state10=this.state,index=_state10.index,shouldPlay=_state10.shouldPlay;var _props6=this.props,steps=_props6.steps,type=_props6.type;var el=e.currentTarget.className.indexOf('joyride-')===0&&e.currentTarget.tagName==='A'?e.currentTarget:e.target;var dataType=el.dataset.type;if(el.className.indexOf('joyride-')===0){e.preventDefault();e.stopPropagation();var tooltip=document.querySelector('.joyride-tooltip');var newIndex=index+(dataType==='back'?-1:1);if(dataType==='skip'){this.setState({skipped:true});newIndex=steps.length+1;}if(tooltip.classList.contains('joyride-tooltip--standalone')){this.setState({play:shouldPlay,shouldPlay:undefined,standaloneTooltip:undefined,redraw:true});}else if(dataType){var shouldDisplay=['continuous','guided'].indexOf(type)>-1&&['close','skip'].indexOf(dataType)===-1&&Boolean(steps[newIndex]);this.toggleTooltip(shouldDisplay,newIndex,dataType);}if(e.target.className==='joyride-overlay'){this.triggerCallback({action:'click',type:callbackTypes.OVERLAY,step:steps[index]});}if(e.target.classList.contains('joyride-hole')){this.triggerCallback({action:'click',type:callbackTypes.HOLE,step:steps[index]});}}}/**
   * Toggle Tooltip's visibility
   *
   * @private
   * @param {Boolean} show - Render the tooltip or the beacon
   * @param {Number} [newIndex] - The tour's new index
   * @param {string} [action]
   */},{key:'toggleTooltip',value:function toggleTooltip(show,newIndex){var action=arguments.length>2&&arguments[2]!==undefined?arguments[2]:'';var _state11=this.state,index=_state11.index,play=_state11.play;var steps=this.props.steps;var nextIndex=newIndex!==undefined?newIndex:index;var step=steps[nextIndex];if(step&&!document.querySelector(step.selector)){console.warn('Target not mounted, skipping...',step,action);//eslint-disable-line no-console
nextIndex+=action==='back'?-1:1;}this.setState({action:action,play:steps[nextIndex]?play:false,showTooltip:show,index:nextIndex,position:undefined,redraw:!show,xPos:-1000,yPos:-1000});}/**
   * Position absolute elements next to its target
   *
   * @private
   * @param {Function} callback - Method to call after placement is set in state
   */},{key:'calcPlacement',value:function calcPlacement(callback){var _state12=this.state,index=_state12.index,play=_state12.play,standaloneTooltip=_state12.standaloneTooltip,showTooltip=_state12.showTooltip;var _props7=this.props,steps=_props7.steps,tooltipOffset=_props7.tooltipOffset;var step=standaloneTooltip||steps[index]||{};var displayTooltip=standaloneTooltip?true:showTooltip;var target=document.querySelector(step.selector);var placement={x:-1000,y:-1000};this.logger('joyride:calcPlacement'+this.getRenderStage(),['step:',step]);if(!target){return;}if(step&&(standaloneTooltip||play&&steps[index])){var offsetX=_nestedProperty2.default.get(step,'style.beacon.offsetX')||0;var offsetY=_nestedProperty2.default.get(step,'style.beacon.offsetY')||0;var position=this.calcPosition(step);var body=this.getScrollContainer().getBoundingClientRect();var component=this.getElementDimensions(displayTooltip?'.joyride-tooltip':'.joyride-beacon');var rect=target.getBoundingClientRect();// Calculate x position
if(/^left/.test(position)){placement.x=rect.left-(displayTooltip?component.width+tooltipOffset:component.width/2+offsetX);}else if(/^right/.test(position)){placement.x=rect.left+rect.width-(displayTooltip?-tooltipOffset:component.width/2-offsetX);}else{placement.x=rect.left+(rect.width/2-component.width/2);}// Calculate y position
if(/^top/.test(position)){placement.y=rect.top-body.top-(displayTooltip?component.height+tooltipOffset:component.height/2+offsetY);}else if(/^bottom/.test(position)){placement.y=rect.top-body.top+(rect.height-(displayTooltip?-tooltipOffset:component.height/2-offsetY));}else{placement.y=rect.top-body.top;}if(/^bottom|^top/.test(position)){if(/left/.test(position)){placement.x=rect.left-(displayTooltip?tooltipOffset:component.width/2);}else if(/right/.test(position)){placement.x=rect.left+(rect.width-(displayTooltip?component.width-tooltipOffset:component.width/2));}}this.setState({xPos:this.preventWindowOverflow(Math.ceil(placement.x),'x',component.width,component.height),yPos:this.preventWindowOverflow(Math.ceil(placement.y),'y',component.width,component.height),redraw:false},function(){if(typeof callback==='function'){// Execute callback after the scrolling transition is finished
setTimeout(function(){callback();},50);}});}}/**
   * Update position for small screens.
   *
   * @private
   * @param {Object} step
   *
   * @returns {string}
   */},{key:'calcPosition',value:function calcPosition(step){var _state13=this.state,showTooltip=_state13.showTooltip,standaloneTooltip=_state13.standaloneTooltip;var tooltipOffset=this.props.tooltipOffset;var displayTooltip=standaloneTooltip?true:showTooltip;var body=this.getScrollContainer().getBoundingClientRect();var target=document.querySelector(step.selector);var component=this.getElementDimensions(displayTooltip?'.joyride-tooltip':'.joyride-beacon');var rect=target.getBoundingClientRect();var position=step.position;//    this.logger('joyride:calcPosition', ['step:', step, 'component:', component, 'rect:', rect]);
if(/^left/.test(position)&&rect.left-(component.width+tooltipOffset)<0){position='top';}else if(/^right/.test(position)&&rect.left+rect.width+(component.width+tooltipOffset)>body.width){position='bottom';}return position;}},{key:'getRenderStage',value:function getRenderStage(){var _state14=this.state,redraw=_state14.redraw,xPos=_state14.xPos;if(redraw){return':redraw';}else if(xPos<0){return':pre-render';}return'';}/**
   * Prevent tooltip to render outside the window
   *
   * @private
   * @param {Number} value - The axis position
   * @param {String} axis - The Axis X or Y
   * @param {Number} elWidth - The target element width
   * @param {Number} elHeight - The target element height
   * @returns {Number}
   */},{key:'preventWindowOverflow',value:function preventWindowOverflow(value,axis,elWidth,elHeight){var winWidth=window.innerWidth;var body=this.getScrollContainer();var html=document.documentElement;var docHeight=Math.max(body.scrollHeight,body.offsetHeight,html.clientHeight,html.scrollHeight,html.offsetHeight);var newValue=value;if(axis==='x'){if(value+elWidth>=winWidth){newValue=winWidth-elWidth-15;}else if(value<15){newValue=15;}}else if(axis==='y'){if(value+elHeight>=docHeight){newValue=docHeight-elHeight-15;}else if(value<15){newValue=15;}}return newValue;}/**
   * Create a React Element
   *
   * @private
   * @returns {*}
   */},{key:'createComponent',value:function createComponent(){var _state15=this.state,index=_state15.index,redraw=_state15.redraw,showTooltip=_state15.showTooltip,standaloneTooltip=_state15.standaloneTooltip,xPos=_state15.xPos,yPos=_state15.yPos;var _props8=this.props,disableOverlay=_props8.disableOverlay,holePadding=_props8.holePadding,locale=_props8.locale,showBackButton=_props8.showBackButton,showOverlay=_props8.showOverlay,showSkipButton=_props8.showSkipButton,showStepsProgress=_props8.showStepsProgress,steps=_props8.steps,type=_props8.type;var currentStep=standaloneTooltip||steps[index];var step=_extends({},currentStep);var target=step&&step.selector?document.querySelector(step.selector):null;var cssPosition=target?target.style.position:null;var shouldShowOverlay=standaloneTooltip?false:showOverlay;var buttons={primary:locale.close};var component=void 0;this.logger('joyride:createComponent'+this.getRenderStage(),['component:',showTooltip||standaloneTooltip?'Tooltip':'Beacon','animate:',xPos>-1&&!redraw,'step:',step],!target);if(!target){return false;}if(showTooltip||standaloneTooltip){step.position=this.calcPosition(step);if(!standaloneTooltip){if(['continuous','guided'].indexOf(type)>-1){buttons.primary=locale.last;if(steps[index+1]){if(showStepsProgress){var next=locale.next;if(typeof locale.next==='string'){next=_react2.default.createElement('span',null,locale.next);}buttons.primary=_react2.default.createElement('span',null,next,' ',_react2.default.createElement('span',null,index+1+'/'+steps.length));}else{buttons.primary=locale.next;}}if(showBackButton&&index>0){buttons.secondary=locale.back;}}if(showSkipButton){buttons.skip=locale.skip;}}component=_react2.default.createElement(_Tooltip2.default,{animate:xPos>-1&&!redraw,buttons:buttons,cssPosition:cssPosition,disableOverlay:disableOverlay,holePadding:holePadding,showOverlay:shouldShowOverlay,step:step,standalone:Boolean(standaloneTooltip),type:type,xPos:xPos+(step.offsetX||0),yPos:yPos+(step.offsetY||0),onClick:this.onClickTooltip,onRender:this.onRenderTooltip});}else{component=_react2.default.createElement(_Beacon2.default,{cssPosition:cssPosition,step:step,xPos:xPos+(step.offsetX||0),yPos:yPos+(step.offsetY||0),onTrigger:this.onClickBeacon,eventType:step.type||'click'});}return component;}},{key:'render',value:function render(){var _state16=this.state,index=_state16.index,play=_state16.play,standaloneTooltip=_state16.standaloneTooltip;var steps=this.props.steps;var hasStep=Boolean(steps[index]);var component=void 0;var standaloneComponent=void 0;if(play&&hasStep){this.logger('joyride:render'+this.getRenderStage(),['step:',steps[index]]);}else if(!play&&standaloneTooltip){this.logger('joyride:render',['tooltip:',standaloneTooltip]);}if(standaloneTooltip){standaloneComponent=this.createComponent();}else if(play&&hasStep){component=this.createComponent();}return _react2.default.createElement('div',{className:'joyride'},component,standaloneComponent);}}]);return Joyride;}(_react2.default.Component),_class.propTypes={callback:_react2.default.PropTypes.func,debug:_react2.default.PropTypes.bool,disableOverlay:_react2.default.PropTypes.bool,holePadding:_react2.default.PropTypes.number,keyboardNavigation:_react2.default.PropTypes.bool,locale:_react2.default.PropTypes.object,resizeDebounce:_react2.default.PropTypes.bool,resizeDebounceDelay:_react2.default.PropTypes.number,run:_react2.default.PropTypes.bool,scrollContainerSelector:_react2.default.PropTypes.string,scrollOffset:_react2.default.PropTypes.number,scrollToFirstStep:_react2.default.PropTypes.bool,scrollToSteps:_react2.default.PropTypes.bool,showBackButton:_react2.default.PropTypes.bool,showOverlay:_react2.default.PropTypes.bool,showSkipButton:_react2.default.PropTypes.bool,showStepsProgress:_react2.default.PropTypes.bool,steps:_react2.default.PropTypes.array,tooltipOffset:_react2.default.PropTypes.number,type:_react2.default.PropTypes.string},_class.defaultProps={debug:false,holePadding:5,keyboardNavigation:true,locale:{back:'Back',close:'Close',last:'Last',next:'Next',skip:'Skip'},resizeDebounce:false,resizeDebounceDelay:200,run:false,scrollContainerSelector:'',scrollToSteps:true,scrollOffset:20,scrollToFirstStep:false,showBackButton:true,showOverlay:true,showSkipButton:false,showStepsProgress:false,steps:[],tooltipOffset:15,type:'single'},_temp);exports.default=Joyride;